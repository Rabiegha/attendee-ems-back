// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [citext]
}

model Organization {
  id         String   @id @default(uuid()) @db.Uuid
  name       String
  slug       String   @unique @db.Citext
  timezone   String?
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  // Relations
  users                 User[]
  roles                 Role[]       // Rôles personnalisés de l'organisation
  invitations           Invitation[]
  attendees             Attendee[]
  orgActivitySectors    OrgActivitySector[]
  orgEventTypes         OrgEventType[]
  attendeeTypes         AttendeeType[]
  badgeTemplates        BadgeTemplate[]
  emailSenders          EmailSender[]
  events                Event[]
  tags                  Tag[]
  badges                Badge[]

  @@map("organizations")
}

model User {
  id            String   @id @default(uuid()) @db.Uuid
  org_id        String   @db.Uuid
  email         String   @db.Citext
  password_hash String
  role_id       String   @db.Uuid
  first_name    String?
  last_name     String?
  phone         String?
  company       String?
  job_title     String?
  country       String?
  metadata      Json?
  is_active     Boolean  @default(true)
  reset_token String?
  reset_token_expires_at DateTime?
  created_at    DateTime @default(now()) @map("created_at")
  updated_at    DateTime @updatedAt @map("updated_at")

  // Relations
  // Cascade: Si l'organisation est supprimée, tous ses utilisateurs sont supprimés
  organization Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  // Restrict: Empêche la suppression d'un rôle s'il a des utilisateurs assignés
  role         Role         @relation(fields: [role_id], references: [id], onDelete: Restrict)
  refreshTokens RefreshToken[]
  // Relations inverses pour les invitations envoyées
  sent_invitations Invitation[]
  generatedBadges  Badge[]  // Badges générés par cet utilisateur

  @@unique([email, org_id])
  @@unique([id, org_id])
  @@unique([reset_token])
  @@index([org_id])
  @@index([role_id])
  @@map("users")
}

model Role {
  id              String        @id @default(uuid()) @db.Uuid
  org_id          String?       @db.Uuid  // NULL = rôle système (template), non-NULL = rôle organisation
  code            String
  name            String
  description     String?
  level           Int           @default(99)  // Hiérarchie: 0=SUPER_ADMIN, 1=ADMIN, 2=MANAGER, 3=PARTNER, 4=VIEWER, 5=HOSTESS
  is_system_role  Boolean       @default(false)  // true = template non modifiable
  created_at      DateTime      @default(now()) @map("created_at")
  updated_at      DateTime      @updatedAt @map("updated_at")

  // Relations
  organization    Organization? @relation(fields: [org_id], references: [id], onDelete: Cascade)
  users           User[]
  invitations     Invitation[]
  rolePermissions RolePermission[]

  @@unique([org_id, code])  // Code unique par organisation
  @@index([org_id])
  @@index([is_system_role])
  @@map("roles")
}

enum PermissionScope {
  any
  org
  assigned
  own
  none
}

model Permission {
  id          String          @id @default(uuid()) @db.Uuid
  code        String          // ex: "events.read" (sans scope)
  scope       PermissionScope @default(none)
  name        String
  description String?
  created_at  DateTime        @default(now()) @map("created_at")
  updated_at  DateTime        @updatedAt @map("updated_at")

  // Relations
  rolePermissions RolePermission[]

  @@unique([code, scope], name: "code_scope")
  @@map("permissions")
}

model RolePermission {
  role_id       String   @db.Uuid
  permission_id String   @db.Uuid
  created_at    DateTime @default(now()) @map("created_at")
  updated_at    DateTime @updatedAt @map("updated_at")

  // Relations
  // Cascade: Si le rôle ou la permission est supprimé, les associations sont supprimées
  role         Role         @relation(fields: [role_id], references: [id], onDelete: Cascade)
  permission   Permission   @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  @@id([role_id, permission_id])
  @@index([role_id])
  @@index([permission_id])
  @@map("role_permissions")
}

model RefreshToken {
  id           String   @id @default(cuid())
  userId       String   @db.Uuid
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  jti          String   @unique              // ID logique du refresh (JWT ID)
  tokenHash    String                        // hash du refresh token (pas de stockage en clair)
  userAgent    String?                       // forensics / device management
  ip           String?                       // forensics
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  revokedAt    DateTime?                     // null = actif
  replacedById String?                       // jti du nouveau token (pour détecter la réutilisation)

  @@index([userId])
  @@index([jti])
  @@index([expiresAt])
  @@map("refresh_tokens")

}

model Invitation {
  id               String            @id @default(uuid()) @db.Uuid
  email            String            @db.Citext
  token            String            @unique
  expires_at       DateTime
  org_id           String            @db.Uuid
  role_id          String            @db.Uuid
  invited_by_user_id String          @db.Uuid
  status           InvitationStatus  @default(PENDING)
  created_at       DateTime          @default(now()) @map("created_at")
  updated_at       DateTime          @updatedAt @map("updated_at")

  // Relations
  // Cascade: Si l'organisation est supprimée, ses invitations sont supprimées
  organization     Organization      @relation(fields: [org_id], references: [id], onDelete: Cascade)
  // Restrict: Empêche la suppression d'un rôle s'il a des invitations en cours
  role             Role              @relation(fields: [role_id], references: [id], onDelete: Restrict)
  // Restrict: Empêche la suppression d'un utilisateur s'il a envoyé des invitations
  invited_by       User              @relation(fields: [invited_by_user_id], references: [id], onDelete: Restrict)

  @@unique([email, org_id]) // Un email ne peut avoir qu'une invitation active par organisation
  @@index([org_id])
  @@index([role_id])
  @@index([invited_by_user_id])
  @@index([token])
  @@index([status])
  @@index([expires_at])
  @@map("invitations")
}

enum InvitationStatus {
  PENDING   // En attente de validation
  ACCEPTED  // Acceptée (compte créé)
  EXPIRED   // Expirée
  CANCELLED // Annulée par l'admin
}

model Attendee {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  default_type_id String?  @db.Uuid

  email           String   @db.Citext
  first_name      String?
  last_name       String?
  phone           String?
  company         String?
  job_title       String?
  country         String?
  metadata        Json?

  labels          String[] @db.Text
  notes           String?

  is_active       Boolean  @default(true)
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  revisions       AttendeeRevision[]
  registrations   Registration[]

  @@unique([org_id, email], name: "org_id_email")
  @@unique([id, org_id], name: "id_org_id")
  @@index([org_id])
  @@index([default_type_id])
  @@index([email])
  @@map("attendees")
}

model AttendeeRevision {
  id          String   @id @default(uuid()) @db.Uuid
  org_id      String   @db.Uuid
  attendee_id String   @db.Uuid
  change_type String   // 'import' | 'merge' | 'manual' | 'upsert'
  source      String?  // 'api' | 'ui' | 'csv:<file>'
  snapshot    Json
  changed_by  String?  @db.Uuid
  note        String?
  changed_at  DateTime @default(now())

  // Relations
  attendee    Attendee @relation(fields: [attendee_id], references: [id], onDelete: Cascade)

  @@index([org_id, attendee_id])
  @@index([attendee_id])
  @@map("attendee_revisions")
}

// ===== Activity Sectors =====
model OrgActivitySector {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  code            String
  name            String
  color_hex       String?
  text_color_hex  String?
  icon            String?
  parent_id       String?  @db.Uuid
  is_active       Boolean  @default(true)
  sort_order      Int      @default(0)
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  parent          OrgActivitySector? @relation("SectorHierarchy", fields: [parent_id, org_id], references: [id, org_id], onDelete: Restrict, onUpdate: NoAction)
  children        OrgActivitySector[] @relation("SectorHierarchy")
  events          Event[]

  @@unique([org_id, code])
  @@unique([id, org_id])
  @@index([org_id, parent_id, sort_order])
  @@map("org_activity_sectors")
}

// ===== Event Types =====
model OrgEventType {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  code            String
  name            String
  color_hex       String?
  text_color_hex  String?
  icon            String?
  is_active       Boolean  @default(true)
  sort_order      Int      @default(0)
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  events          Event[]

  @@unique([org_id, code])
  @@unique([id, org_id])
  @@index([org_id, sort_order])
  @@map("org_event_types")
}

// ===== Attendee Types =====
model AttendeeType {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  code            String
  name            String
  color_hex       String?
  text_color_hex  String?
  icon            String?
  is_active       Boolean  @default(true)
  sort_order      Int      @default(0)
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  organization         Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  eventAttendeeTypes   EventAttendeeType[]

  @@unique([org_id, code])
  @@unique([id, org_id])
  @@index([org_id, sort_order])
  @@index([org_id, name])
  @@map("attendee_types")
}

// ===== Badge Templates =====
model BadgeTemplate {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  event_id        String?  @db.Uuid // Optionnel : template global ou spécifique à un événement
  code            String
  name            String
  description     String?  @db.Text
  html            String?  @db.Text // Code HTML du template (généré par GrapesJS)
  css             String?  @db.Text // CSS du template (généré par GrapesJS)
  width           Int      @default(400) // Largeur du badge en pixels
  height          Int      @default(600) // Hauteur du badge en pixels
  template_data   Json?    // Données GrapesJS complètes (pour ré-éditer)
  variables       Json?    // Variables utilisées: ["attendee_name", "company", "qrcode", etc.]
  is_default      Boolean  @default(false) // Template par défaut de l'org
  is_active       Boolean  @default(true)
  usage_count     Int      @default(0) // Nombre de fois utilisé
  created_by      String?  @db.Uuid // ID de l'utilisateur qui a créé le template
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  organization         Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  event                Event?       @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  eventSettings        EventSetting[]
  eventAttendeeTypeBadges EventAttendeeTypeBadge[]
  registrations        Registration[]
  badges               Badge[]

  @@unique([org_id, code])
  @@unique([id, org_id])
  @@index([org_id])
  @@index([org_id, event_id])
  @@index([org_id, is_default])
  @@map("badge_templates")
}

// ===== Email Senders =====
model EmailSender {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  from_name       String
  from_email      String   @db.Citext
  reply_to_email  String?  @db.Citext
  is_active       Boolean  @default(true)
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  organization    Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  emailSettings   EmailSetting[]

  @@unique([org_id, from_email])
  @@unique([id, org_id])
  @@index([org_id])
  @@map("email_senders")
}

// ===== Events =====
model Event {
  id                      String   @id @default(uuid()) @db.Uuid
  org_id                  String   @db.Uuid
  code                    String
  name                    String
  org_activity_sector_id  String?  @db.Uuid
  org_event_type_id       String?  @db.Uuid
  description             String?  @db.Text
  start_at                DateTime
  end_at                  DateTime
  timezone                String   @default("UTC")
  status                  EventStatus @default(draft)
  capacity                Int?
  location_type           LocationType @default(physical)
  address_formatted       String?
  address_street          String?
  address_city            String?
  address_region          String?
  address_postal_code     String?
  address_country         String?
  latitude                Decimal? @db.Decimal(9, 6)
  longitude               Decimal? @db.Decimal(9, 6)
  place_id                String?
  created_by              String?  @db.Uuid
  created_at              DateTime @default(now()) @map("created_at")
  updated_at              DateTime @updatedAt @map("updated_at")
  deleted_at              DateTime? @map("deleted_at")

  // Relations
  organization            Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  activitySector          OrgActivitySector? @relation(fields: [org_activity_sector_id, org_id], references: [id, org_id], onDelete: SetNull, onUpdate: NoAction)
  eventType               OrgEventType? @relation(fields: [org_event_type_id, org_id], references: [id, org_id], onDelete: SetNull, onUpdate: NoAction)
  settings                EventSetting?
  emailSettings           EmailSetting?
  eventAttendeeTypes      EventAttendeeType[]
  registrations           Registration[]
  eventAccess             EventAccess[]
  subevents               Subevent[]
  partnerScans            PartnerScan[]
  eventTags               EventTag[]
  badgeTemplates          BadgeTemplate[] // Templates de badges pour cet événement
  badges                  Badge[]         // Badges générés pour cet événement

  @@unique([id, org_id])
  @@unique([org_id, code])
  @@index([org_id])
  @@index([org_id, start_at])
  @@index([org_id, status])
  @@index([org_id, org_activity_sector_id])
  @@index([org_id, org_event_type_id])
  @@map("events")
}

enum EventStatus {
  draft
  published
  registration_closed
  cancelled
  postponed
  archived
}

enum LocationType {
  physical
  online
  hybrid
}

enum AttendanceMode {
  onsite
  online
  hybrid
}

// ===== Event Settings (1:1 with Event) =====
model EventSetting {
  id                              String   @id @default(uuid()) @db.Uuid
  org_id                          String   @db.Uuid
  event_id                        String   @unique @db.Uuid
  website_url                     String?
  logo_asset_id                   String?
  attendance_mode                 AttendanceMode @default(onsite)
  registration_auto_approve       Boolean  @default(false)
  allow_checkin_out               Boolean  @default(true)
  has_event_reminder              Boolean  @default(false)
  badge_template_id               String?  @db.Uuid
  public_token                    String   @unique
  registration_fields             Json?
  submit_button_text              String?
  submit_button_color             String?
  show_title                      Boolean  @default(true)
  show_description                Boolean  @default(true)
  is_dark_mode                    Boolean  @default(false)
  auto_transition_to_active       Boolean  @default(true)
  auto_transition_to_completed    Boolean  @default(true)
  extra                           Json?
  created_at                      DateTime @default(now()) @map("created_at")
  updated_at                      DateTime @updatedAt @map("updated_at")

  // Relations
  event                           Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  badgeTemplate                   BadgeTemplate? @relation(fields: [badge_template_id, org_id], references: [id, org_id], onDelete: SetNull, onUpdate: NoAction)

  @@unique([event_id, org_id])
  @@index([org_id, event_id])
  @@index([public_token])
  @@map("event_settings")
}

// ===== Email Settings (1:1 with Event) =====
model EmailSetting {
  id                          String   @id @default(uuid()) @db.Uuid
  org_id                      String   @db.Uuid
  event_id                    String   @unique @db.Uuid
  email_sender_id             String?  @db.Uuid
  
  // Email verification
  require_email_verification  Boolean  @default(false)
  
  // Confirmation email (envoyé à l'inscription)
  confirmation_enabled        Boolean  @default(false)
  confirmation_subject        String?
  confirmation_body           String?  @db.Text
  
  // Approval email (envoyé quand inscription approuvée)
  approval_enabled            Boolean  @default(false)
  approval_subject            String?
  approval_body               String?  @db.Text
  
  // Reminder email
  reminder_enabled            Boolean  @default(false)
  reminder_subject            String?
  reminder_body               String?  @db.Text
  reminder_hours_before       Int?
  
  created_at                  DateTime @default(now()) @map("created_at")
  updated_at                  DateTime @updatedAt @map("updated_at")

  // Relations
  event                       Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  emailSender                 EmailSender? @relation(fields: [email_sender_id, org_id], references: [id, org_id], onDelete: SetNull, onUpdate: NoAction)

  @@unique([event_id, org_id])
  @@index([org_id, event_id])
  @@map("email_settings")
}

// ===== Event Attendee Types =====
model EventAttendeeType {
  id                String   @id @default(uuid()) @db.Uuid
  event_id          String   @db.Uuid
  org_id            String   @db.Uuid
  attendee_type_id  String   @db.Uuid
  capacity          Int?
  sort_order        Int      @default(0)
  created_at        DateTime @default(now()) @map("created_at")
  updated_at        DateTime @updatedAt @map("updated_at")

  // Relations
  event             Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  attendeeType      AttendeeType @relation(fields: [attendee_type_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  registrations     Registration[]
  badges            EventAttendeeTypeBadge[]

  @@unique([id, event_id, org_id])
  @@unique([event_id, attendee_type_id])
  @@index([org_id, event_id, sort_order])
  @@map("event_attendee_types")
}

// ===== Event Attendee Type Badges =====
model EventAttendeeTypeBadge {
  event_attendee_type_id  String   @db.Uuid
  badge_template_id       String   @db.Uuid
  org_id                  String   @db.Uuid
  created_at              DateTime @default(now()) @map("created_at")

  // Relations
  eventAttendeeType       EventAttendeeType @relation(fields: [event_attendee_type_id], references: [id], onDelete: Cascade)
  badgeTemplate           BadgeTemplate @relation(fields: [badge_template_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)

  @@id([event_attendee_type_id, badge_template_id])
  @@index([org_id])
  @@map("event_attendee_type_badges")
}

// ===== Registrations =====
model Registration {
  id                      String   @id @default(uuid()) @db.Uuid
  org_id                  String   @db.Uuid
  event_id                String   @db.Uuid
  attendee_id             String   @db.Uuid
  status                  RegistrationStatus @default(awaiting)
  attendance_type         AttendanceMode @default(onsite)
  answers                 Json?
  event_attendee_type_id  String?  @db.Uuid
  badge_template_id       String?  @db.Uuid
  invited_at              DateTime?
  confirmed_at            DateTime?
  checked_in_at           DateTime? @map("checked_in_at")
  deleted_at              DateTime? @map("deleted_at")
  created_at              DateTime @default(now()) @map("created_at")
  updated_at              DateTime @updatedAt @map("updated_at")
  
  // Source de l'inscription (pour distinguer test/réel)
  source                  RegistrationSource @default(public_form) @map("source")
  
  // Snapshot des données de l'attendee au moment de l'inscription
  snapshot_first_name     String?  @map("snapshot_first_name")
  snapshot_last_name      String?  @map("snapshot_last_name")
  snapshot_email          String?  @map("snapshot_email")
  snapshot_phone          String?  @map("snapshot_phone")
  snapshot_company        String?  @map("snapshot_company")
  snapshot_job_title      String?  @map("snapshot_job_title")
  snapshot_country        String?  @map("snapshot_country")

  // Badge URLs (générés par le backend)
  badge_pdf_url           String?  @map("badge_pdf_url")
  badge_image_url         String?  @map("badge_image_url")
  comment                 String?
  checked_in_by           String?  @db.Uuid
  checkin_location        Json?

  // Relations
  event                   Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  attendee                Attendee @relation(fields: [attendee_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  eventAttendeeType       EventAttendeeType? @relation(fields: [event_attendee_type_id], references: [id], onDelete: SetNull)
  badgeTemplate           BadgeTemplate? @relation(fields: [badge_template_id, org_id], references: [id, org_id], onDelete: SetNull, onUpdate: NoAction)
  badges                  Badge[]
  presenceVisits          PresenceVisit[]

  @@unique([event_id, attendee_id])
  @@unique([id, event_id, org_id])
  @@index([org_id, event_id, status])
  @@index([org_id, attendee_id])
  @@index([org_id, event_id, event_attendee_type_id])
  @@map("registrations")
}

enum RegistrationStatus {
  awaiting
  approved
  refused
  cancelled
}

enum RegistrationSource {
  public_form  // Inscription via formulaire public (vraie inscription)
  test_form    // Inscription via formulaire de test (fake)
  manual       // Créée manuellement par un admin
  import       // Importée via Excel
  mobile_app   // Inscription via l'application mobile
}

// ===== Badges =====
enum BadgeStatus {
  pending      // En attente de génération
  generating   // En cours de génération
  completed    // Généré avec succès
  failed       // Échec de génération
}

model Badge {
  id                String       @id @default(uuid()) @db.Uuid
  org_id            String       @db.Uuid
  registration_id   String       @db.Uuid
  badge_template_id String       @db.Uuid
  event_id          String       @db.Uuid
  
  // URLs des fichiers générés
  pdf_url           String?      // URL du PDF sur Cloudflare R2
  image_url         String?      // URL de l'image preview (optionnel)
  
  // Données du badge (ancienne structure, gardée pour compatibilité)
  badge_data        Json?
  qr_code_url       String?
  
  // Métadonnées de génération
  generated_at      DateTime?    @map("generated_at")
  generated_by      String?      @db.Uuid
  
  // Snapshot du contenu au moment de la génération (pour audit trail)
  html_snapshot     String?      @db.Text
  css_snapshot      String?      @db.Text
  data_snapshot     Json?
  
  // Statut de génération
  status            BadgeStatus  @default(pending)
  error_message     String?      @db.Text
  
  // Suivi d'impression
  print_count       Int          @default(0)
  last_printed_at   DateTime?    @map("last_printed_at")
  
  created_at        DateTime     @default(now()) @map("created_at")
  updated_at        DateTime     @updatedAt @map("updated_at")

  // Relations
  registration      Registration  @relation(fields: [registration_id], references: [id], onDelete: Cascade)
  badgeTemplate     BadgeTemplate @relation(fields: [badge_template_id, org_id], references: [id, org_id], onDelete: Restrict, onUpdate: NoAction)
  organization      Organization  @relation(fields: [org_id], references: [id], onDelete: Cascade)
  event             Event         @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  generatedByUser   User?         @relation(fields: [generated_by], references: [id], onDelete: SetNull)
  prints            BadgePrint[]

  @@unique([id, org_id])
  @@unique([registration_id]) // Un seul badge par registration
  @@index([org_id, registration_id])
  @@index([org_id, event_id])
  @@index([badge_template_id])
  @@index([status])
  @@index([generated_at])
  @@map("badges")
}

// ===== Badge Prints =====
model BadgePrint {
  id          String   @id @default(uuid()) @db.Uuid
  org_id      String   @db.Uuid
  badge_id    String   @db.Uuid
  printed_by  String?  @db.Uuid
  printed_at  DateTime @default(now())

  // Relations
  badge       Badge @relation(fields: [badge_id], references: [id], onDelete: Cascade)

  @@index([org_id, badge_id])
  @@index([printed_at])
  @@map("badge_prints")
}

// ===== Subevents (Phase 3) =====
model Subevent {
  id          String   @id @default(uuid()) @db.Uuid
  org_id      String   @db.Uuid
  event_id    String   @db.Uuid
  name        String
  start_at    DateTime
  end_at      DateTime
  location    String?
  created_at  DateTime @default(now()) @map("created_at")
  updated_at  DateTime @updatedAt @map("updated_at")

  // Relations
  event       Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([id, org_id])
  @@index([org_id, event_id])
  @@map("subevents")
}

// ===== Partner Scans (Phase 3) =====
model PartnerScan {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  event_id        String   @db.Uuid
  scanned_by      String   @db.Uuid
  attendee_data   Json
  scanned_at      DateTime @default(now())

  // Relations
  event           Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)

  @@index([org_id, event_id])
  @@index([scanned_at])
  @@map("partner_scans")
}

// ===== Presence Visits (Phase 3 - check-in intervals) =====
model PresenceVisit {
  id              String   @id @default(uuid()) @db.Uuid
  org_id          String   @db.Uuid
  registration_id String   @db.Uuid
  checked_in_at   DateTime
  checked_out_at  DateTime?
  created_at      DateTime @default(now()) @map("created_at")
  updated_at      DateTime @updatedAt @map("updated_at")

  // Relations
  registration    Registration @relation(fields: [registration_id], references: [id], onDelete: Cascade)

  @@index([org_id, registration_id])
  @@index([checked_in_at])
  @@map("presence_visits")
}

// ===== Event Access (user assignment to events) =====
model EventAccess {
  id          String   @id @default(uuid()) @db.Uuid
  org_id      String   @db.Uuid
  event_id    String   @db.Uuid
  user_id     String   @db.Uuid
  reason      String?
  granted_by  String?  @db.Uuid
  expires_at  DateTime?
  created_at  DateTime @default(now()) @map("created_at")
  updated_at  DateTime @updatedAt @map("updated_at")

  // Relations
  event       Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([org_id, event_id, user_id])
  @@index([org_id, user_id])
  @@index([org_id, event_id])
  @@map("event_access")
}

// ===== Tags System =====

model Tag {
  id          String   @id @default(uuid()) @db.Uuid
  org_id      String   @db.Uuid
  name        String   // Nom du tag (ex: "Technologie", "Networking")
  color       String?  // Couleur optionnelle pour l'affichage (hex)
  usage_count Int      @default(0) // Nombre d'événements utilisant ce tag
  created_at  DateTime @default(now()) @map("created_at")
  updated_at  DateTime @updatedAt @map("updated_at")

  // Relations
  organization Organization @relation(fields: [org_id], references: [id], onDelete: Cascade)
  eventTags    EventTag[]

  @@unique([org_id, name]) // Un tag unique par nom dans une org
  @@index([org_id])
  @@index([org_id, usage_count(sort: Desc)]) // Pour trier par popularité
  @@map("tags")
}

model EventTag {
  event_id   String   @db.Uuid
  org_id     String   @db.Uuid
  tag_id     String   @db.Uuid
  created_at DateTime @default(now()) @map("created_at")

  // Relations
  event Event @relation(fields: [event_id, org_id], references: [id, org_id], onDelete: Cascade, onUpdate: NoAction)
  tag   Tag   @relation(fields: [tag_id], references: [id], onDelete: Cascade)

  @@id([event_id, tag_id])
  @@index([org_id, event_id])
  @@index([tag_id])
  @@map("event_tags")
}
